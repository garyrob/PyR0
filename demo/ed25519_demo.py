#!/usr/bin/env python3
"""Demo of Ed25519 signature verification using RISC Zero zkVM"""

import os
import sys
import time
from pathlib import Path

os.environ['RISC0_DEV_MODE'] = '0'

# Fresh import
import pyr0
from pyr0 import serialization

# Debug: check what we actually imported
print(f"Imported pyr0 from: {pyr0.__file__}")
print(f"Using new API: {hasattr(pyr0, 'prove')}")

# Constants
GUEST_DIR = Path(__file__).parent / "ed25519_demo_guest"
PUBLIC_KEY = "d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a"
VALID_SIG = "e5564300c360ac729086e2cc806e828a84877f1eb8e5d974d873e065224901555fb8821590a33bacc61e39701cf9b46bd25bf5f0595bbe24655141438e7a100b"
INVALID_SIG = "3b41da0837e8f4e7b1ba8d9e0db233a22a5764c84e8870c049e7e210c512a4532dbab6222d5e98dd50fe0fb186c039fe9a0387bf43de1fbf655c101db2540b06"
MESSAGE = ""

# Build and load the guest program using the new API
print("\nBuilding guest program...")
try:
    # Build guest (auto-detects binary name from Cargo.toml)
    elf_path = pyr0.build_guest(GUEST_DIR)
    print(f"✓ Guest built at: {elf_path}")
    
    # Load the ELF
    with open(elf_path, "rb") as f:
        elf_data = f.read()
    image = pyr0.load_image(elf_data)
    print("✓ ELF loaded into image")
except pyr0.GuestBuildFailedError as e:
    print(f"❌ Build failed: {e}")
    sys.exit(1)
except pyr0.ElfNotFoundError as e:
    print(f"❌ ELF not found: {e}")
    sys.exit(1)
except Exception as e:
    print(f"❌ Unexpected error: {e}")
    sys.exit(1)

# Get and display the program's unique ID
PROGRAM_ID = image.id.hex()
print(f"✓ Program ID: {PROGRAM_ID[:16]}...{PROGRAM_ID[-16:]}")
print(f"  (Full ID: {PROGRAM_ID})")

# Test with valid signature
print("\n=== Test 1: Valid Signature ===")
pk_bytes = bytes.fromhex(PUBLIC_KEY)
sig_bytes = bytes.fromhex(VALID_SIG)
msg_bytes = MESSAGE.encode('utf-8')

# Use the new API - prove() accepts bytes directly
# The serialization helper creates the proper format for the guest
input_data = serialization.ed25519_input(pk_bytes, sig_bytes, msg_bytes)

print(f"Input size: {len(input_data)} bytes")
print("Executing and generating proof...")

# Use the new unified prove() function
start = time.time()
receipt = pyr0.prove(image, input_data)
proof_time = time.time() - start
journal = receipt.journal

print(f"Journal: {len(journal)} bytes")
print(f"First 10 bytes: {journal[:10]}")

if len(journal) < 4:
    print("❌ CRITICAL ERROR: Journal too short (< 4 bytes) - guest program likely crashed!")
    sys.exit(1)

if journal[0] != 99:
    print(f"❌ ERROR: Expected marker 99, got {journal[0]} - guest program malfunction!")
    sys.exit(1)

print("✓ Guest started (marker 99)")

# The guest is committing u8 values, but journal stores them as u32 words
# Each commit becomes 4 bytes in the journal
if len(journal) < 16:
    print(f"❌ ERROR: Journal too short ({len(journal)} bytes, need 16) - guest crashed after start!")
    sys.exit(1)

# Read as u32 values (little-endian)
import struct
marker = struct.unpack('<I', journal[0:4])[0]  # Should be 99
pk_size = struct.unpack('<I', journal[4:8])[0]  # Should be 32
sig_size = struct.unpack('<I', journal[8:12])[0]  # Should be 64
msg_size = struct.unpack('<I', journal[12:16])[0]  # Should be 0
print(f"Vector sizes: pk={pk_size}, sig={sig_size}, msg={msg_size}")

if len(journal) < 20:
    print(f"❌ ERROR: Journal too short ({len(journal)} bytes, need 20) - guest didn't commit result!")
    sys.exit(1)

# The result byte is at position 16
result = struct.unpack('<I', journal[16:20])[0]
if result == 1:
    print("✅ Signature VALID - Test PASSED")
elif result == 0:
    print("❌ Signature reported as INVALID - Test FAILED")
elif result == 200:
    print("❌ Size mismatch error")
elif result == 201:
    print("❌ Invalid public key error")
else:
    print(f"Unexpected result: {result}")

# Proof was already generated by prove()
print(f"\nProof generated in {proof_time:.2f}s")

# Verify the receipt's program ID matches our expected program
receipt_program_id = receipt.program_id.hex()
if receipt_program_id != PROGRAM_ID:
    print(f"❌ ERROR: Program ID mismatch!")
    print(f"  Expected: {PROGRAM_ID}")
    print(f"  Got:      {receipt_program_id}")
    sys.exit(1)
print(f"✓ Program ID verified: {receipt_program_id[:16]}...{receipt_program_id[-16:]}")

# Verify the cryptographic proof
receipt.verify(image.id)  # Pass the trusted image ID
print("✓ Proof verified")

# Test with invalid signature
print("\n=== Test 2: Invalid Signature ===")
sig_bytes = bytes.fromhex(INVALID_SIG)

input_data = serialization.ed25519_input(pk_bytes, sig_bytes, msg_bytes)

# For the second test, we just execute, no need for proof
info = pyr0.dry_run(image, input_data)
journal = info.journal

print(f"Journal: {len(journal)} bytes")

if len(journal) < 20:
    print(f"❌ ERROR: Journal too short ({len(journal)} bytes, need 20) - guest crashed!")
    sys.exit(1)

if journal[0] != 99:
    print(f"❌ ERROR: Expected marker 99, got {journal[0]} - guest malfunction!")
    sys.exit(1)

import struct
result = struct.unpack('<I', journal[16:20])[0]
test_passed = False
if result == 0:
    print("✅ Signature INVALID - Test PASSED")
    test_passed = True
elif result == 1:
    print("❌ Signature reported as VALID - Test FAILED")
else:
    print(f"❌ Unexpected result: {result}")

print("\n=== Summary ===")
if test_passed:
    print("✓ Both tests passed! The zkVM correctly validates Ed25519 signatures!")
    print("These are real cryptographic proofs in production mode.")
    sys.exit(0)
else:
    print("✗ Some tests failed")
    sys.exit(1)