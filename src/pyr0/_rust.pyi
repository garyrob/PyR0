"""Type stubs for PyR0 Rust extension module."""

from typing import Union, Optional, List, Tuple, overload, Literal
from enum import Enum

# Enums
class ReceiptKind(Enum):
    COMPOSITE: ReceiptKind
    SUCCINCT: ReceiptKind
    GROTH16: ReceiptKind
    FAKE: ReceiptKind

class ExitKind(Enum):
    HALTED: ExitKind
    PAUSED: ExitKind
    SYSTEM_SPLIT: ExitKind
    SESSION_LIMIT: ExitKind
    UNKNOWN: ExitKind

# Classes
class Image:
    @property
    def id(self) -> bytes: ...
    @property
    def id_hex(self) -> str: ...
    @property
    def image_id_bytes(self) -> bytes: ...
    @property
    def elf_size(self) -> int: ...

class ExitStatus:
    @property
    def kind(self) -> ExitKind: ...
    @property
    def user_code(self) -> Optional[int]: ...
    @property
    def ok(self) -> bool: ...

class Claim:
    @property
    def image_id(self) -> bytes: ...
    @property
    def image_id_hex(self) -> str: ...
    @property
    def journal(self) -> bytes: ...
    @property
    def journal_digest(self) -> bytes: ...
    @property
    def journal_digest_hex(self) -> str: ...
    @property
    def exit_code(self) -> int: ...
    @property
    def is_success(self) -> bool: ...
    
    def matches(self, image_id: bytes, journal: bytes) -> bool: ...

class VerifierContext:
    """Context for efficient batch verification of receipts."""
    def __init__(self) -> None: ...
    def clear(self) -> None: ...

class Receipt:
    # Journal properties
    @property
    def journal_bytes(self) -> bytes: ...
    @property
    def journal_hex(self) -> str: ...
    @property
    def journal_text(self) -> Optional[str]: ...
    @property
    def journal_len(self) -> int: ...
    @property
    def journal(self) -> bytes: ...  # Legacy
    
    # Claim
    def claim(self) -> Claim: ...
    
    # Image ID (untrusted!)
    @property
    def claimed_image_id_hex(self) -> str: ...
    @property
    def claimed_image_id_bytes(self) -> bytes: ...
    @property
    def program_id(self) -> bytes: ...  # Legacy
    
    # Receipt properties
    @property
    def seal_size(self) -> int: ...
    @property
    def kind(self) -> ReceiptKind: ...
    @property
    def is_unconditional(self) -> bool: ...
    @property
    def is_succinct(self) -> bool: ...
    @property
    def assumption_count(self) -> int: ...
    
    # Exit status
    @property
    def exit(self) -> ExitStatus: ...
    @property
    def exit_code(self) -> int: ...  # Legacy
    
    # Verification - polymorphic!
    @overload
    def verify(self, image_id: bytes) -> None: ...
    @overload
    def verify(self, image_id: str) -> None: ...
    @overload
    def verify(self, image_id: Image) -> None: ...
    
    def verify_hex(self, image_id_hex: str) -> None: ...
    def verify_bytes(self, image_id: bytes) -> None: ...
    def verify_integrity(self) -> None: ...
    def verify_with_image_id(self, image_id: Union[bytes, str, Image]) -> None: ...  # Deprecated
    def verify_with_context(self, image_id: Union[bytes, str, Image], context: VerifierContext) -> None: ...
    def verify_integrity_with_context(self, context: VerifierContext) -> None: ...
    
    def matches_image_id(self, expected_image_id: bytes) -> bool: ...
    
    # Serialization
    def to_bytes(self) -> bytes: ...
    @staticmethod
    def from_bytes(data: bytes) -> 'Receipt': ...

class Composer:
    def __init__(self, image: Image) -> None: ...
    
    # Assumption management
    def assume(self, receipt: Receipt) -> None: ...
    def assume_many(self, receipts: List[Receipt]) -> None: ...
    
    # Writers for env::read_slice()
    def write_u32(self, value: int) -> None: ...
    def write_u64(self, value: int) -> None: ...
    def write_bytes32(self, data: bytes) -> None: ...
    def write_image_id(self, image_id: bytes) -> None: ...
    def write_slice(self, data: bytes) -> None: ...
    
    # Writers for env::read::<T>()
    def write_vec_u8(self, data: bytes) -> None: ...
    def write_string(self, text: str) -> None: ...
    
    # Utilities
    def write_journal_from(self, receipt: Receipt) -> None: ...
    
    # Verification setup
    def expect_verification(self, image_id: bytes, journal: bytes) -> None: ...
    def preflight_check(self, raise_on_error: bool = True) -> List[str]: ...
    
    # Proving - polymorphic!
    @overload
    def prove(self, *, preflight: bool = True) -> Receipt: ...
    @overload
    def prove(self, *, kind: ReceiptKind, preflight: bool = True) -> Receipt: ...
    @overload
    def prove(self, *, kind: Literal["succinct", "composite", "groth16"], preflight: bool = True) -> Receipt: ...
    
    # Properties
    @property
    def input_size(self) -> int: ...
    @property
    def assumption_count(self) -> int: ...

class SessionInfo:
    @property
    def exit_code(self) -> 'ExitCode': ...
    @property
    def journal(self) -> bytes: ...

class ExitCode:
    Halted: int
    Paused: int
    SystemSplit: int

# Functions
def load_image(elf: bytes) -> Image: ...

def prove(image: Image, input_bytes: bytes) -> Receipt: ...

def prove_with_opts(
    image: Image, 
    input_bytes: bytes, 
    succinct: bool = False
) -> Receipt: ...

def prove_succinct(image: Image, input_bytes: bytes) -> Receipt: ...

def compute_image_id_hex(elf_bytes: bytes) -> str: ...

def compress_to_succinct(
    receipt: Receipt,
    assumptions: Optional[List[Receipt]] = None
) -> Receipt: ...

def dry_run(image: Image, input_bytes: bytes) -> SessionInfo: ...